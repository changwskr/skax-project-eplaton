/**
 * @최초작성자 컴스퀘어 정 재원
 * @최초작성일 2007.09.03
 * @수정일        2007.09.04 ( MergeHashMap , MergeSession  메소드 추가 )
 * @수정일        2007.09.10 ( Split  메소드 추가 )
 *
 */

package com.kbstar.mbc.fc.foundation.bzcrudbus.foundation.utility;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Properties;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;

import kr.co.comsquare.db.SaveResultSet;
import kr.co.comsquare.rwXmlLib.RwXml;
import kr.co.comsquare.util.Tokenizer;

import com.oreilly.servlet.multipart.MultipartParser;
import com.oreilly.servlet.multipart.ParamPart;
import com.oreilly.servlet.multipart.Part;

public class TrustFormUtil {

	// 세션 유지 시간 지정 ( 초 단위 지정 )
	private int MAX_SESSION_TIME = -1;

	/**
	 * request의 파라미터들을 HashMap으로 변환
	 */
	public HashMap RequestTOHashMap(HttpServletRequest request) {
		HashMap RequestHashMap = new HashMap(); // Return 시 사용될 HashMap

		// 리퀘스트의 모든 파라미터들을 Enumeration객체에 저장
		Enumeration requestEnumeration = request.getParameterNames();

		while (requestEnumeration.hasMoreElements()) {
			String strEnumeration = (String) requestEnumeration.nextElement();

			// Enumeration객체에서 하나씩 빼와서 HashMap에 저장
			RequestHashMap.put(strEnumeration, (String) request.getParameter(strEnumeration));
		}
		// 리퀘스트에서 추출한 HashMap에 세션에 있는 변수들을 Merge
		RequestHashMap = MergeSession(request, RequestHashMap);

		// 세션 유지 시간 연장
		HttpSession session = request.getSession(false);
		session.setMaxInactiveInterval(MAX_SESSION_TIME);

		request.setAttribute("success", "");
		request.setAttribute("fail", "");

		try {
		

			System.out.println("======================================================================");

			for (Iterator all = RequestHashMap.keySet().iterator(); all
					.hasNext();) {
				String each = (String) all.next();
				try {
					System.out.println(each + " : "
							+ RequestHashMap.get(each).toString().trim());
				} catch (NullPointerException e) {
					System.out.println(each + " : NULL");
				}
			}

			System.out.println("======================================================================");
		} catch (Exception e) {
			e.printStackTrace();
		}
		return RequestHashMap;

	}

	/**
	 * MultiPart로 넘오온 파라미터들을 HashMap으로 변환
	 * 
	 * @throws IOException
	 */
	public HashMap MultiPartTOHashMap(HttpServletRequest request)
			throws IOException {

		HashMap RequestHashMap = new HashMap(); // Return 시 사용될 HashMap

		ClassLoader load = getClass().getClassLoader();
		InputStream in = load
				.getResourceAsStream("kdic/dbas/common/upload/upload.properties");
		Properties property = new Properties();

		try {
			property.load(in);
		} catch (IOException e) {
			e.printStackTrace();
		}

		int maxSize = Integer.parseInt((String) property.get("maxSize"));

		MultipartParser mp = new MultipartParser(request, maxSize, true, true,
				"UTF-8");
		Part part;

		while ((part = mp.readNextPart()) != null) {
			String name = part.getName();

			// 파라미터인 경우
			if (part.isParam()) {
				ParamPart paramPart = (ParamPart) part;
				RequestHashMap.put(name, paramPart.getStringValue());
			}

		}

		// 리퀘스트에서 추출한 HashMap에 세션에 있는 변수들을 Merge
		RequestHashMap = MergeSession(request, RequestHashMap);

		request.setAttribute("success", "");
		request.setAttribute("fail", "");

		return RequestHashMap;

	}

	/**
	 * 그리드의 멀티업데이트 정보를 HashMap에 담은 리스트를 HashMap으로 return param : 멀티업데이트 정보가 담긴
	 * 파라미터 명 mode : i(그리드에 추가된 내용) , u(그리드에서 변경된 내용) , d(그리드에서 삭제된 내용) 중 원하는 정보
	 * 입력
	 */
	public HashMap getRs(HttpServletRequest request, String param) {

		String data = request.getParameter(param);

		SaveResultSet insertRs = new SaveResultSet();
		SaveResultSet updateRs = new SaveResultSet();
		SaveResultSet deleteRs = new SaveResultSet();

		SaveResultSet result = new SaveResultSet();

		ArrayList list = new ArrayList();

		HashMap resultMap = new HashMap();

		// 화면에서 넘어온 데이터를 상태flag에 따라 Tokenizer를 이용하여 분리
		Tokenizer.getSaveResultSet(data, insertRs, updateRs, deleteRs);

		result = insertRs;

		// 그리드 멀티업데이트 정보 중 insert에 해당하는 정보를 List에 저장
		if (result.getTotalRow() > 0) {

			String[] arr = result.getColNameArray();

			while (result.next()) {
				HashMap map = new HashMap();

				for (int i = 0; i < arr.length; i++) {
					map.put(arr[i], result.get(arr[i]));
				}
				// 그리드의 col정보가 담긴 HashMap에 세션 정보 추가
				map = MergeSession(request, map);

				list.add(map);
			}
			resultMap.put("i", list);
		}

		result = updateRs;
		list = new ArrayList();

		// 그리드 멀티업데이트 정보 중 update에 해당하는 정보를 List에 저장
		if (result.getTotalRow() > 0) {

			String[] arr = result.getColNameArray();

			while (result.next()) {
				HashMap map = new HashMap();

				for (int i = 0; i < arr.length; i++) {
					map.put(arr[i], result.get(arr[i]));
				}

				// 그리드의 col정보가 담긴 HashMap에 세션 정보 추가
				map = MergeSession(request, map);

				list.add(map);
			}
			resultMap.put("u", list);
		}

		result = deleteRs;
		list = new ArrayList();

		// 그리드 멀티업데이트 정보 중 delete에 해당하는 정보를 List에 저장
		if (result.getTotalRow() > 0) {

			String[] arr = result.getColNameArray();

			while (result.next()) {
				HashMap map = new HashMap();

				for (int i = 0; i < arr.length; i++) {
					map.put(arr[i], result.get(arr[i]));
				}

				// 그리드의 col정보가 담긴 HashMap에 세션 정보 추가
				map = MergeSession(request, map);

				list.add(map);
			}
			resultMap.put("d", list);
		}

		return resultMap;
	}

	/**
	 * 그리드의 멀티업데이트 정보를 HashMap에 담은 리스트를 HashMap으로 return param : 멀티업데이트 정보가 담긴
	 * 파라미터 명 mode : i(그리드에 추가된 내용) , u(그리드에서 변경된 내용) , d(그리드에서 삭제된 내용) 중 원하는 정보
	 * 입력
	 */
	public HashMap getRs(HttpServletRequest request, HashMap inputmap,
			String param) {

		Part part;

		String data = inputmap.get(param).toString().trim();

		SaveResultSet insertRs = new SaveResultSet();
		SaveResultSet updateRs = new SaveResultSet();
		SaveResultSet deleteRs = new SaveResultSet();

		SaveResultSet result = new SaveResultSet();

		ArrayList list = new ArrayList();

		HashMap resultMap = new HashMap();

		// 화면에서 넘어온 데이터를 상태flag에 따라 Tokenizer를 이용하여 분리
		Tokenizer.getSaveResultSet(data, insertRs, updateRs, deleteRs);

		result = insertRs;

		// 그리드 멀티업데이트 정보 중 insert에 해당하는 정보를 List에 저장
		if (result.getTotalRow() > 0) {

			String[] arr = result.getColNameArray();

			while (result.next()) {
				HashMap map = new HashMap();

				for (int i = 0; i < arr.length; i++) {
					map.put(arr[i], result.get(arr[i]));
				}
				// 그리드의 col정보가 담긴 HashMap에 세션 정보 추가
				map = MergeSession(request, map);

				list.add(map);
			}
			resultMap.put("i", list);
		}

		result = updateRs;
		list = new ArrayList();

		// 그리드 멀티업데이트 정보 중 update에 해당하는 정보를 List에 저장
		if (result.getTotalRow() > 0) {

			String[] arr = result.getColNameArray();

			while (result.next()) {
				HashMap map = new HashMap();

				for (int i = 0; i < arr.length; i++) {
					map.put(arr[i], result.get(arr[i]));
				}

				// 그리드의 col정보가 담긴 HashMap에 세션 정보 추가
				map = MergeSession(request, map);

				list.add(map);
			}
			resultMap.put("u", list);
		}

		result = deleteRs;
		list = new ArrayList();

		// 그리드 멀티업데이트 정보 중 delete에 해당하는 정보를 List에 저장
		if (result.getTotalRow() > 0) {

			String[] arr = result.getColNameArray();

			while (result.next()) {
				HashMap map = new HashMap();

				for (int i = 0; i < arr.length; i++) {
					map.put(arr[i], result.get(arr[i]));
				}

				// 그리드의 col정보가 담긴 HashMap에 세션 정보 추가
				map = MergeSession(request, map);

				list.add(map);
			}
			resultMap.put("d", list);
		}

		return resultMap;
	}

	/**
	 * 2개의 HashMap을 하나의 HashMap으로 Merge후 리턴
	 */
	public HashMap MergeHashMap(HashMap merge_A, HashMap merge_B) {

		for (Iterator all = merge_A.keySet().iterator(); all.hasNext();) {
			String each = (String) all.next();
			try {
				merge_B.put(each, merge_A.get(each).toString().trim());
			} catch (Exception e) {
				merge_B.put(each, "");
			}
		}

		return merge_B;

	}

	/**
	 * HashMap에 세션정보 추가후 HashMap을 리턴
	 */
	public HashMap MergeSession(HttpServletRequest request, HashMap result) {

		HttpSession session = request.getSession(false);

		// session객체의 모든 값을 Enumeration객체에 저장
		Enumeration sessionEnumeration = session.getAttributeNames();

		while (sessionEnumeration.hasMoreElements()) {
			String strEnumeration = (String) sessionEnumeration.nextElement();
			// Enumeration객체에서 하나씩 빼와서 HashMap에 저장
			try {
				result.put(strEnumeration, (String) session
						.getAttribute(strEnumeration));
			} catch (Exception e) {
				continue;
			}
		}
		// 개발자중 로컬에서 포털을 실행안하고 F5키로 미리보기창에서 작업을 하는 경우 디폴트로 세션정보 지정
		if (result.get("SESSION_USR_ID") == null) {
			result.put("SESSION_USR_ID", "2054012");
		}
		if (result.get("SESSION_DEPT_CD") == null) {
			result.put("SESSION_DEPT_CD", "EE100");
		}
		if (result.get("SESSION_USR_NM") == null) {
			result.put("SESSION_USR_NM", "이승훈");
		}
		return result;
	}

	/**
	 * HashMap에 세션정보 추가후 HashMap을 리턴
	 */
	public static HashMap ProcedureInpam(HttpServletRequest request,
			HashMap inpam, String param) {

		inpam.put("strInParams", param);
		inpam.put("strUserId", inpam.get("SESSION_USR_ID").toString().trim());
		inpam.put("strUserIp", request.getLocalAddr());
		inpam.put("strHptr", "");
		inpam.put("lngRtn", "");
		inpam.put("strCount", "");
		inpam.put("strDesc", "");

		return inpam;
	}

	/**
	 * before에 담긴 문자열을 key라는 구분자로 ArrayList로 바꿔서 return
	 */
	public ArrayList Split(String before, String key) {

		ArrayList result = new ArrayList();

		String temp[] = before.split(key);

		for (int i = 0; i < temp.length; i++) {
			result.add(temp[i]);
		}

		return result;
	}

	// 그리드에 쓰이는 Xml을 생성해주는 메소드
	public static String makeGridXml(String node, List list) {

		String flushXML = "";

		RwXml rx = new RwXml();
		rx.setEncoding("UTF-8");
		int root = RwXml.rootNodeID;
		int res = 0;
		int res2 = 0;

		res = rx.add(root, node, "");

		for (int i = 0; i < list.size(); i++) {

			HashMap map = (HashMap) list.get(i);

			res2 = rx.add(res, "list", "");

			for (Iterator all = map.keySet().iterator(); all.hasNext();) {
				String each = (String) all.next();
				try {
					rx.add(res2, each, map.get(each).toString(), true);
				} catch (NullPointerException e) {
					rx.add(res2, each, "");
				}
			}
		}

		flushXML = rx.xmlFlush();
		flushXML += rx.xmlEndFlush();

		return flushXML;
	}

	// 콤보 컨트럴에 쓰이는 XML을 생성해주는 메소드 ( 콤보에 전체도 추가 )
	public static String makeComboAllXml(String node, List list) {

		String flushXML = "";

		RwXml rx = new RwXml();
		rx.setEncoding("UTF-8");
		int root = RwXml.rootNodeID;
		int res = 0;
		int res2 = 0;

		res = rx.add(root, node, "");

		res2 = rx.add(res, "combo", "");
		rx.add(res2, "LABEL", "전체");
		rx.add(res2, "VALUE", "");

		for (int i = 0; i < list.size(); i++) {

			HashMap map = (HashMap) list.get(i);

			res2 = rx.add(res, "combo", "");

			for (Iterator all = map.keySet().iterator(); all.hasNext();) {
				String each = (String) all.next();
				try {
					rx.add(res2, each, map.get(each).toString().trim(), true);
				} catch (NullPointerException e) {
					rx.add(res2, each, "");
				}
			}
		}

		flushXML = rx.xmlFlush();
		flushXML += rx.xmlEndFlush();

		return flushXML;
	}

	// 콤보 컨트럴에 쓰이는 XML을 생성해주는 메소드
	public static String makeComboXml(String node, List list) {

		String flushXML = "";

		RwXml rx = new RwXml();
		rx.setEncoding("UTF-8");
		int root = RwXml.rootNodeID;
		int res = 0;
		int res2 = 0;

		res = rx.add(root, node, "");

		for (int i = 0; i < list.size(); i++) {

			HashMap map = (HashMap) list.get(i);

			res2 = rx.add(res, "combo", "");

			for (Iterator all = map.keySet().iterator(); all.hasNext();) {
				String each = (String) all.next();
				try {
					rx.add(res2, each, map.get(each).toString().trim(), true);
				} catch (NullPointerException e) {
					rx.add(res2, each, "");
				}
			}
		}

		flushXML = rx.xmlFlush();
		flushXML += rx.xmlEndFlush();

		return flushXML;
	}

	// 콤보 컨트럴에 쓰이는 XML을 생성해주는 메소드
	public static String makeComboXml(String node, List list, boolean total) {

		String flushXML = "";

		RwXml rx = new RwXml();
		rx.setEncoding("UTF-8");
		int root = RwXml.rootNodeID;
		int res = 0;
		int res2 = 0;

		res = rx.add(root, node, "");

		if (total) {
			res2 = rx.add(res, "combo", "");
			rx.add(res2, "LABEL", "전체");
			rx.add(res2, "VALUE", "");
		}

		for (int i = 0; i < list.size(); i++) {

			HashMap map = (HashMap) list.get(i);

			res2 = rx.add(res, "combo", "");

			for (Iterator all = map.keySet().iterator(); all.hasNext();) {
				String each = (String) all.next();
				try {
					rx.add(res2, each, map.get(each).toString().trim(), true);
				} catch (NullPointerException e) {
					rx.add(res2, each, "");
				}
			}
		}

		flushXML = rx.xmlFlush();
		flushXML += rx.xmlEndFlush();

		return flushXML;
	}

	public static String makeXml(String node, HashMap map) {

		String flushXML = "";

		RwXml rx = new RwXml();
		rx.setEncoding("UTF-8");
		int root = RwXml.rootNodeID;
		int res = 0;

		res = rx.add(root, node, "");

		for (Iterator all = map.keySet().iterator(); all.hasNext();) {
			String each = (String) all.next();
			try {
				rx.add(res, each, map.get(each).toString().trim(), true);
			} catch (NullPointerException e) {
				rx.add(res, each, "");
			}
		}

		flushXML = rx.xmlFlush();
		flushXML += rx.xmlEndFlush();

		return flushXML;
	}

	public static String makeSingleXml(String node, List list) {

		String flushXML = "";

		RwXml rx = new RwXml();
		rx.setEncoding("UTF-8");
		int root = RwXml.rootNodeID;
		int res = 0;

		res = rx.add(root, node, "");
		HashMap map = (HashMap) list.get(0);

		for (Iterator all = map.keySet().iterator(); all.hasNext();) {
			String each = (String) all.next();
			try {
				rx.add(res, each, map.get(each).toString().trim(), true);
			} catch (NullPointerException e) {
				rx.add(res, each, "");
			}
		}

		flushXML = rx.xmlFlush();
		flushXML += rx.xmlEndFlush();

		return flushXML;
	}
}
